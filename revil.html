<!DOCTYPE html>
<html lang="en">
<head>
    <title>OSCollab</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"/>
    <link rel="stylesheet" href="res/style.css"/>
</head>
<body>

<canvas id="viewport" width="800" height="500"></canvas>
<br/>
<button onclick="btnClick()">Boop</button>

<script src="node_modules/osc/dist/osc-browser.min.js"></script>
<script src="bundle.js"></script>
<script>
    var revil = new Revil("127.0.0.1", 8211);
    var colors = ["#ff0000", "#00ff00", "#0000ff", "#ffff00", "00ffff", "ff00ff"];

    var pads = [];

    var canvas = document.getElementById("viewport").getContext("2d");

    var drawShape = function (x, y, width, height, color, colorProperty, drawMethod, endMethod) {
        canvas[colorProperty] = color;
        canvas.beginPath();
        canvas[drawMethod](x, y, width, height);
        canvas[endMethod]();
    };

    var drawRect = function (x, y, width, height, color, fill) {
        if (fill)
            drawShape(x, y, width, height, color, "fillStyle", "fillRect", "fill");
        else
            drawShape(x, y, width, height, color, "strokeStyle", "rect", "stroke");
    };

    var draw = function () {
        drawRect(0, 0, 800, 500, "#ffffff", true);

        for (var i = 0; i < pads.length; i++) {
            var pad = pads[i];
            drawRect(pad.position.x, pad.position.y, pad.dimensions.width, pad.dimensions.height, pad.color, true);
            drawRect(pad.position.x, pad.position.y, pad.dimensions.width, pad.dimensions.height, "#000000", false);


        }
    };



    var Pad = function (markerId, theme, color, dimensions, position, rotation) {
        this.markerId = markerId;
        this.theme = theme || "1";
        this.color = color || colors[Math.floor(Math.random() * colors.length)];
        this.dimensions = dimensions || {width: 100, height: 100, depth: 100};
        this.position = position || {x: 0, y: 0, z: 0};
        this.rotation = rotation || {rx: 0, ry: 0, rz: 0};
    };

    var getPad = function (markerId) {
        for (var i = 0; i < pads.length; i++) {
            if (pads[i].markerId === markerId)
                return pads[i];
        }
        return null;
    };

    var addPad = function (markerId, theme, color, dimensions, position, rotation) {
        revil.send("/revil/scene/add_shape", ["pad_" + markerId], function () {
            var pad = new Pad(markerId, theme, color, dimensions, position, rotation);
            pads.push(pad);
        });
    };

    var shapes = {
        "shape_1": ["1"], // Revealed by theme 1
        "shape_2": ["2"], // Revealed by theme 2
        "shape_3": ["1", "2"], // Revealed by both theme 1 and 2
        "shape_4": ["1+2"] // Revealed only when theme 1 and 2 collaborate
    };

    // Detect collaboration based on proximity of the pads
    var proxemicsDetection = function (padA, padB) {
        var deltaX = padA.position.x - padB.position.x;
        var deltaY = padA.position.y - padB.position.y;
        var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        return distance <= 2;
    };

    // Detect collaboration based on orientation of the pads
    var compassDetection = function (padA, padB) {
        return false;
    };

    // Changes both pads' theme to the combined theme of the pads
    var additiveAffectation = function (padA, padB) {
        return padA.theme + "+" + padB.theme;
    };

    // Returns true if padA and padB are collaborating according to the detection method
    var areCollaborating = function (padA, padB, method) {
        return method(padA, padB);
    };

    // Changes the theme of padA and padB according to the affectation method
    var collaborate = function (padA, padB, method) {
        padA.theme = method(padA, padB);
        padB.theme = method(padA, padB);
    };

    // Checks for collaboration between pads
    var updateCollaboration = function () {
        for (var i = 0; i < pads.length; i++) {
            for (var j = 0; j < pads.length; j++) {
                var padA = pads[i];
                var padB = pads[j];
                if (padA.name !== padB.name) {
                    if (areCollaborating(padA, padB, proxemicsDetection)) {
                        collaborate(padA, padB, additiveAffectation);
                    }
                }
            }
        }
    };

    var updateShape = function (shape) {
        var revealedBy = [];
        var themes = shapes[shape];
        for (var i = 0; i < themes.length; i++) { // For each theme of the shape
            for (var j = 0; j < pads.length; j++) { // For each pad
                var pad = pads[j];
                if (themes[i] === pad.theme) { // If there is a pad with a matching theme
                    revealedBy.push(pad.markerId); // Add the pad's marker id to the shape's revealed_by
                }
            }
        }
        revil.send("/revil/scene/" + shape + "/revealed_by", revealedBy, function () {
            console.log("Changed revealed_by of " + shape + " to " + revealedBy);
        });
    };

    // Sets the appropriate revealed_by parameter for each shape
    var updateShapes = function () {
        for (var shape in shapes) { // For each shape
            if (shapes.hasOwnProperty(shape)) {
                updateShape(shape);
            }
        }
    };

    // Triggers every 100ms
    var update = function () {
        updateCollaboration();
        updateShapes();
        draw();
    };
    window.setInterval(update, 100);

    // Triggers when a marker is detected
    var markerDetected = function (markerId, position, rotation) {
        var pad = getPad(markerId);
        if (pad === null) {
            addPad(markerId, "" + (markerId % 3 + 1), undefined, undefined, position, rotation);
        }
        else {
            pad.position = position;
            pad.rotation = rotation;
        }
        revil.send("/revil/scene/pad_" + markerId + "/position", [pad.position], function () {
            console.log("Updated pad_" + markerId + " position from markers");
        });
        revil.send("/revil/scene/pad_" + markerId + "/rotation", [pad.rotation], function () {
            console.log("Updated pad_" + markerId + " rotation from markers");
        });
    };

    revil.addRoutes({
        "revil": {
            "spaces": {
                "space": {
                    "depthcam": {
                        "marker_output": function (args) {
                            var markerId = args[0];
                            var position = {x: args[1], y: args[2], z: args[3]};
                            var rotation = {rx: args[4], ry: args[5], rz: args[6]};
                            markerDetected(markerId, position, rotation);
                        }
                    }
                }
            }
        }
    });

    //(node:14679) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 11 close listeners added. Use emitter.setMaxListeners() to increase limit


    var btnClick = function () {
        console.log(pads);
    };
</script>
</body>
</html>
