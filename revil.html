<!DOCTYPE html>
<html lang="en">
<head>
    <title>OSCollab</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"/>
    <link rel="stylesheet" href="res/style.css"/>
</head>
<body>

<canvas id="viewport" width="800" height="500"></canvas>
<br/>
<button onclick="btnClick()">Boop</button>

<script src="node_modules/osc/dist/osc-browser.min.js"></script>
<script src="bundle.js"></script>
<script>
    var revil = new Revil("127.0.0.1", 8211);
    var colors = ["#ff0000", "#00ff00", "#0000ff", "#ffff00", "00ffff", "ff00ff"];

    var pads = [];

    var canvas = document.getElementById("viewport").getContext("2d");

    var drawShape = function (x, y, width, height, color, colorProperty, drawMethod, endMethod) {
        canvas[colorProperty] = color;
        canvas.beginPath();
        canvas[drawMethod](x, y, width, height);
        canvas[endMethod]();
    };

    var drawRect = function (x, y, width, height, color, fill) {
        if (fill)
            drawShape(x, y, width, height, color, "fillStyle", "fillRect", "fill");
        else
            drawShape(x, y, width, height, color, "strokeStyle", "rect", "stroke");
    };

    var draw = function () {
        drawRect(0, 0, 800, 500, "#ffffff", true);

        for (var i = 0; i < pads.length; i++) {
            var pad = pads[i];
            drawRect(pad.position.x, pad.position.y, pad.dimensions.width, pad.dimensions.height, pad.color, true);
            drawRect(pad.position.x, pad.position.y, pad.dimensions.width, pad.dimensions.height, "#000000", false);


        }
    };

    // Returns true if padA and padB are collaborating according to the detection method
    var areCollaborating = function (padA, padB, method) {
        return method(padA, padB);
    };
    // Collaboration detection methods
    var proxemicsDetection = function (padA, padB) {
        var deltaX = padA.position.x - padB.position.x;
        var deltaY = padA.position.y - padB.position.y;
        var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        return distance <= 2;
    };

    // Changes the theme of padA and padB according to the affectation method
    var collaborate = function(padA, padB, method) {
        padA.theme = method(padA, padB);
        padB.theme = method(padA, padB);
    };
    // Collaboration affectation methods
    var additiveAffectation = function (padA, padB) {
        return padA.theme + "+" + padB.theme;
    };

    var update = function () {
        for (var i = 0; i < pads.length; i++) {
            for (var j = 0; j < pads.length; j++) {
                var padA = pads[i];
                var padB = pads[j];
                if (padA.name !== padB.name) {
                    if (areCollaborating(padA, padB, proxemicsDetection)) {
                        collaborate(padA, padB, additiveAffectation);
                    }
                }
            }
        }

        draw();
    };
    window.setInterval(update, 200);


    var Pad = function (name, theme, color, dimensions, position, rotation) {
        this.name = name;
        this.theme = theme || 1;
        this.color = color || colors[Math.floor(Math.random() * colors.length)];
        this.dimensions = dimensions || {width: 100, height: 100, depth: 100};
        this.position = position || {x: 0, y: 0, z: 0};
        this.rotation = rotation || {rx: 0, ry: 0, rz: 0};
    };

    var getPad = function (name) {
        for (var i = 0; i < pads.length; i++) {
            if (pads[i].name === name)
                return pads[i];
        }
        return null;
    };

    var configuration = {
        "shape_1": ["1"], // Revealed by theme 1
        "shape_2": ["2"], // Revealed by theme 2
        "shape_3": ["1", "2"], // Revealed by both theme 1 and 2
        "shape_4": ["1+2"] // Revealed only when theme 1 and 2 collaborate
    };

    // Triggers when the shape 'shape' gets revealed by the pad 'padName'
    var revealed = function (shape, padName) {
        var pad = getPad(padName);
        if (pad !== null) {
            var themes = configuration[shape];
            for (var i = 0; i < themes.length; i++) {
                if (themes[i] === pad.theme) {
                    revil.send("/revil/scene/" + shape + "/revealed_by", [pad.theme], function () {
                        console.log("Changed revealed_by of " + shape + " to " + pad.theme);
                    });
                    return true;
                }
            }
        }
        return false;
    };

    var getShapeRoute = function (shape) {
        return {
            "revealed_name": function (args) {
                revealed(shape, "pad_" + args[0]);
            }
        };
    };

    var getShapesRoutes = function () {
        var routes = {};
        for (var shape in configuration) {
            if (configuration.hasOwnProperty(shape)) {
                routes[shape] = getShapeRoute(shape);
            }
        }
        return routes;
    };

    var addPad = function (name, theme, color, dimensions, position, rotation) {
        revil.send("/revil/scene/add_shape", [name], function () {
            var pad = new Pad(name, theme, color, dimensions, position, rotation);
            pads.push(pad);
        });
    };

    // Triggers when a marker is detected
    var updatePad = function (id, position, rotation) {
        var padName = "pad_" + id;
        var pad = getPad(padName);
        if (pad === null) {
            addPad(padName, "" + (id % 3 + 1), undefined, undefined, position, rotation);
        }
        else {
            pad.position = position;
            pad.rotation = rotation;
        }
        revil.send("/revil/scene/" + padName + "/position", [pad.position], function () {
            console.log("Updated " + padName + " position from markers");
        });
        revil.send("/revil/scene/" + padName + "/rotation", [pad.rotation], function () {
            console.log("Updated " + padName + " rotation from markers");
        });
    };

    revil.addRoutes({
        "revil": {
            "spaces": {
                "space": {
                    "depthcam": {
                        "marker_output": function (args) {
                            var id = args[0];
                            var position = {x: args[1], y: args[2], z: args[3]};
                            var rotation = {rx: args[4], ry: args[5], rz: args[6]};
                            updatePad(id, position, rotation);
                        }
                    }
                }
            },
            "scene": getShapesRoutes()
        }
    });

    //(node:14679) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 11 close listeners added. Use emitter.setMaxListeners() to increase limit


    var btnClick = function () {
        console.log(pads);
    };
</script>
</body>
</html>
